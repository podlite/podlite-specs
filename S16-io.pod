
=encoding utf8

=head1 TITLE

Synopsis 16: I/O

=head1 AUTHORS

    Largely, the authors of the related Perl 5 docs.
    Larry Wall <larry@wall.org>
    Mark Stosberg <mark@summersault.com>
    Tim Nelson <wayland@wayland.id.au>
    Daniel Ruoso <daniel@ruoso.com>
    Elizabeth Mattijsen <liz@dijkmat.nl>

=head1 VERSION

    Created: 12 Sep 2006

    Last Modified: 22 Sep 2014
    Version: 24

Many of these functions will work as in Perl 5, except we're trying to rationalize everything into roles.  For
now you can assume most of the important functions will automatically
be in the * namespace.  However, with IO operations in particular,
many of them are really methods on an IO handle, and if there is a
corresponding global function, it's merely an exported version of
the method.

=head1 IO

=head2 Overridable IO handles

In Perl 6, there are the I<standard> IO handles, and any number of overriding
inner filehandles for the same symbol.

The I<standard> handles are our old familiar friends (with new names).
Standard input changed from STDIN to C<$*IN>, standard output changed
from STDOUT to C<$*OUT>, and standard error changed from STDERR to
C<$*ERR>.  In Perl 6 these symbols represent more of a concept than
a given filehandle, since the meaning is contextually determined.
The process's version of these handles live in the C<PROCESS::>
namespace, which is more global than the per-interpreter C<GLOBAL::>
namespace.

When no explicit filehandle is used, the standard IO operators are
defined in terms of the dynamic variables.  So the C<say> function
prints to C<$*OUT>, while C<note> prints to C<$*ERR>.  The C<< lines() >>
term inputs from C<$*ARGFILES> which defaults to C<$*IN> in the absence of any
filenames.  So any given dynamic scope (interpreter,
thread, function or method call) may redefine the current meaning of
any of those filehandles within the dynamic scope of itself and of
its called routines.

So to put it another way, when you write something like

  say "Howdy, world!"

the C<say> function looks for the current meaning of C<$*OUT>, and
takes the closest definition it can find in its callers.  If none
of the callers have overridden the definition, it looks in the
interpreter's C<GLOBAL> namespace.  If the interpreter hasn't overridden
the meaning, it takes the meaning from C<PROCESS>.  In essence, any
dynamic scope in Perl 6 is allowed to do IO redirection much like
a Unix shell does with its subprocesses, albeit with a different
syntax:

  {
      my $*OUT will leave *.close = open $newfile, :w;
      say "Written to $newfile";
  }
  # stdout reverts to outer scope's definition, and closed the file

=head2 Path Names and the .IO coercer

Path names are just strings (C<Str>).  Methods that return path names, will
just return strings.  As soon as you need to do manipulation on the path name
(e.g. to find out its C<basename> or C<extension>), you can create an
C<IO::Path> object out of the string by applying the C<.IO> coercer:

  my $path = $filename.IO;

Then you can use any of the C<IO::Path> methods, such as C<open>:

  my $handle = $newfile.IO.open(:w);

Note that the C<open()> sub, is just really syntactic sugar for the above:

  my $handle = open $newfile, :w;

=head2 $*SPEC

The current system's path semantics are encapsulated in C<$*SPEC> dynamic
variable.  It adhers to the C<IO::Spec> interface, and is automatically
initialized for the current environment.  But like any dynamic variable,
can be overridden in a scope:

  { # Win32 path semantics in here
      my $*SPEC = IO::Spec::Win32.new;
      ...  # your code
  }
  # original path semantics here again

=head2 $*CWD and chdir()

The dynamic variable $*CWD is an C<IO::Path> object of the current working
directory.  It is normally set with the C<chdir()> function, which will check
whether the specified path exists as a directory.  To facilitate setting a
locally scoped version of $*CWD, you can specify the variable to be set as
a second parameter to C<chdir()>.

  chdir($dir);   # sets $*CWD of outer scope, usually PROCESS::<$*CWD>

  {
      chdir($dir, my $*CWD);  # set $*CWD in this scope
  }

The C<chdir()> function returns a C<X::IO::Chdir> Failure if the path does
not exist, is not accessible, or is not a directory.  Otherwise it will
return C<True>.  Any C<Failure> generally will be thrown immediately if
called like above.

Please note that the path in C<$*CWD> does not have any bearing on what the
underlying operating system's concept of a "current directory".  It is simply
the path that will prepended before any implicit or explicit relative paths,
and the default path that will be used when executing a sub-process.

=head2 $*TMPDIR and chtmpdir()

The dynamic variable C<$*TMPDIR> is an C<IO::Path> object which points to the
system's temporary directory.  It is normally set with the C<chtmpdir()>,
which will check whether the specified path exists as a directory and is
writable.  To facilitate setting a locally scoped version of $*TMPDIR, you
can specify the variable to be set as the second parameter, just as with
C<chdir()>:

  chtmpdir($dir);   # sets $*TMPDIR of outer scope, usually PROCESS::<$*TMPDIR>

  {
      chtmpdir($dir, my $*TMPDIR);  # set $*TMPDIR in this scope
  }

The C<chtmpdir()> function returns a C<X::IO::Chtmpdir> Failure if the path
does not exist, is not accessible, is not a directory or isn't writable.
Otherwise it will return C<True>.

The initialization of C<$*TMPDIR> at startup, is delegated to the C<.tmpdir>
method of the C<$*SPEC> setting that is set at startup.

=head2 $*HOME and chhomedir()

The dynamic variable C<$*HOME> is an C<IO::Path> object which points to the
user's home directory.  It is normally set with the C<chhomedir()>, which will
check whether the specified path exists as a directory and is writable.  To
facilitate setting a locally scoped version of $*HOME, you can specify the
variable to be set as the second parameter, just as with C<chdir()>:

  chhomedir($dir);   # sets $*HOME of outer scope, usually PROCESS::<$*HOME>

  {
      chhomedir($dir, my $*HOME);  # set $*HOME in this scope
  }

The C<chhomedir()> function returns a C<X::IO::Chhomedir> Failure if the path
does not exist, is not accessible, is not a directory or isn't writable.
Otherwise it will return C<True>.

The initialization of C<$*HOME> at startup, is delegated to the C<.homedir>
method of the C<$*SPEC> setting that is set at startup.

=head2 System dependent path semantics and IO::Spec

Each time an C<IO::Path> object is created, the current C<$*SPEC> will be
encapsulated in the object, to be used for all path related operations.

Of course, it is also possible to specify a specify a specific system's
path semantics module when creating an C<IO::Path> object with the C<:SPEC>
named parameter:

  my $SPEC = IO::Spec::Win32.new;
  my $path = $fileonNTFS.IO(:$SPEC);

or:

  my $path = $fileonNTFS.IO(:SPEC<Win32>); # auto-expand to IO::Spec::Win32.new

=head2 Functions, Roles and Classes

The roles and classes that define most of the functionality for IO are defined
in S32-setting-library/IO.pod.  The main functions used are listed in S29 with
references to S32-setting-library/IO.pod.  An overview:

=head3 Functions

  $handle = open($path);        # open a file, return IO::Handle

  chdir($dir);                  # set $*CWD
  chdir($dir, my $*CWD);        # set $*CWD for the current scope

  chtmpdir($dir);               # set $*TMPDIR
  chtmpdir($dir, my $*TMPDIR);  # set $*TMPDIR for the current scope

  chhomedir($dir);              # set $*HOME
  chhomedir($dir, my $*HOME);   # set $*HOME for the current scope

  @relpaths = dir;              # paths (as Str) in $*CWD
  @relpaths = dir($dir);        # paths (as Str) in $dir

  @relpaths = glob($pattern);   # paths (as Str) matching $pattern

  $contents = slurp($handle);   # read all that's left of an opened filehandle
  $contents = slurp($filename); # read all from given filename

  spurt($handle,$contents);     # write $contents to $handle
  spurt($filename,$contents);   # write $contents to $filename

  mkdir($dir);                  # create a directory
  rmdir($dir);                  # remove a directory

  unlink($filename);            # remove a file

=head3 IO::Testable Role

Role to be consumed by both C<IO::Path> as well as C<IO::Handle>.

  $io.r          $!path of $io is readable by effective uid/gid
  $io.w          $!path of $io is writable by effective uid/gid
  $io.x          $!path of $io is executable by effective uid/gid
  $io.o          $!path of $io is owned by effective uid

  $io.R          $!path of $io is readable by real uid/gid
  $io.W          $!path of $io is writable by real uid/gid
  $io.X          $!path of $io is executable by real uid/gid
  $io.O          $!path of $io is owned by real uid

  $io.e          $!path of $io exists
  $io.s          Size of the $!path of $io in bytes
  $io.z          $!path of $io has zero size (an empty file)

  $io.f          $!path of $io is a plain file
  $io.d          $!path of $io is a directory
  $io.l          $!path of $io is a symbolic link
  $io.p          $!path of $io is a named pipe (FIFO)
  $io.S          $!path of $io is a socket
  $io.b          $!path of $io is a block special file
  $io.c          $!path of $io is a character special file

  $io.u          $!path of $io has setuid bit set
  $io.g          $!path of $io has setgid bit set
  $io.k          $!path of $io has sticky bit set

  $io.accessed   last access time of $!path of $io (if available)
  $io.modified   last modified time of $!path of $io
  $io.changed    last (metadata) changed time of $!path of $io

=head3 IO::Spec Class

=head3 IO::Path Class

  class IO::Path is Cool does IO::FileTestable { }

=head3 IO::Handle Class

  class IO::Path does IO::FileTestable { }

=for vim:set expandtab sw=4:
